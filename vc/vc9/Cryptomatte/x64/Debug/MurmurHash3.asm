; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?fmix32@@YAKK@Z					; fmix32
PUBLIC	?getblock32@@YAKPEBKH@Z				; getblock32
PUBLIC	?MurmurHash3_x86_32@@YAXPEBXHKPEAX@Z		; MurmurHash3_x86_32
EXTRN	_rotl:PROC
pdata	SEGMENT
$pdata$?MurmurHash3_x86_32@@YAXPEBXHKPEAX@Z DD imagerel $LN11
	DD	imagerel $LN11+480
	DD	imagerel $unwind$?MurmurHash3_x86_32@@YAXPEBXHKPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?MurmurHash3_x86_32@@YAXPEBXHKPEAX@Z DD 011701H
	DD	0c217H
; Function compile flags: /Odtp
; File c:\users\brendan bolles\documents\development\proexr\ext\smhasher\src\murmurhash3.cpp
xdata	ENDS
_TEXT	SEGMENT
h1$ = 32
c1$ = 36
tail$ = 40
c2$ = 48
nblocks$ = 52
blocks$ = 56
data$ = 64
k1$ = 72
i$4808 = 76
k1$4812 = 80
tv89 = 84
key$ = 112
len$ = 120
seed$ = 128
out$ = 136
?MurmurHash3_x86_32@@YAXPEBXHKPEAX@Z PROC		; MurmurHash3_x86_32

; 96   : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 97   :   const uint8_t * data = (const uint8_t*)key;

	mov	rax, QWORD PTR key$[rsp]
	mov	QWORD PTR data$[rsp], rax

; 98   :   const int nblocks = len / 4;

	mov	eax, DWORD PTR len$[rsp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR nblocks$[rsp], eax

; 99   : 
; 100  :   uint32_t h1 = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR h1$[rsp], eax

; 101  : 
; 102  :   const uint32_t c1 = 0xcc9e2d51;

	mov	DWORD PTR c1$[rsp], -862048943		; cc9e2d51H

; 103  :   const uint32_t c2 = 0x1b873593;

	mov	DWORD PTR c2$[rsp], 461845907		; 1b873593H

; 104  : 
; 105  :   //----------
; 106  :   // body
; 107  : 
; 108  :   const uint32_t * blocks = (const uint32_t *)(data + nblocks*4);

	mov	eax, DWORD PTR nblocks$[rsp]
	shl	eax, 2
	movsxd	rcx, eax
	mov	rax, QWORD PTR data$[rsp]
	add	rax, rcx
	mov	QWORD PTR blocks$[rsp], rax

; 109  : 
; 110  :   for(int i = -nblocks; i; i++)

	mov	eax, DWORD PTR nblocks$[rsp]
	neg	eax
	mov	DWORD PTR i$4808[rsp], eax
	jmp	SHORT $LN8@MurmurHash
$LN7@MurmurHash:
	mov	eax, DWORD PTR i$4808[rsp]
	add	eax, 1
	mov	DWORD PTR i$4808[rsp], eax
$LN8@MurmurHash:
	cmp	DWORD PTR i$4808[rsp], 0
	je	SHORT $LN6@MurmurHash

; 111  :   {
; 112  :     uint32_t k1 = getblock32(blocks,i);

	mov	edx, DWORD PTR i$4808[rsp]
	mov	rcx, QWORD PTR blocks$[rsp]
	call	?getblock32@@YAKPEBKH@Z			; getblock32
	mov	DWORD PTR k1$4812[rsp], eax

; 113  : 
; 114  :     k1 *= c1;

	mov	eax, DWORD PTR k1$4812[rsp]
	imul	eax, -862048943				; cc9e2d51H
	mov	DWORD PTR k1$4812[rsp], eax

; 115  :     k1 = ROTL32(k1,15);

	mov	edx, 15
	mov	ecx, DWORD PTR k1$4812[rsp]
	call	_rotl
	mov	DWORD PTR k1$4812[rsp], eax

; 116  :     k1 *= c2;

	mov	eax, DWORD PTR k1$4812[rsp]
	imul	eax, 461845907				; 1b873593H
	mov	DWORD PTR k1$4812[rsp], eax

; 117  :     
; 118  :     h1 ^= k1;

	mov	ecx, DWORD PTR k1$4812[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h1$[rsp], eax

; 119  :     h1 = ROTL32(h1,13); 

	mov	edx, 13
	mov	ecx, DWORD PTR h1$[rsp]
	call	_rotl
	mov	DWORD PTR h1$[rsp], eax

; 120  :     h1 = h1*5+0xe6546b64;

	mov	eax, DWORD PTR h1$[rsp]
	imul	eax, 5
	add	eax, -430675100				; e6546b64H
	mov	DWORD PTR h1$[rsp], eax

; 121  :   }

	jmp	$LN7@MurmurHash
$LN6@MurmurHash:

; 122  : 
; 123  :   //----------
; 124  :   // tail
; 125  : 
; 126  :   const uint8_t * tail = (const uint8_t*)(data + nblocks*4);

	mov	eax, DWORD PTR nblocks$[rsp]
	shl	eax, 2
	movsxd	rcx, eax
	mov	rax, QWORD PTR data$[rsp]
	add	rax, rcx
	mov	QWORD PTR tail$[rsp], rax

; 127  : 
; 128  :   uint32_t k1 = 0;

	mov	DWORD PTR k1$[rsp], 0

; 129  : 
; 130  :   switch(len & 3)

	mov	eax, DWORD PTR len$[rsp]
	and	eax, 3
	mov	DWORD PTR tv89[rsp], eax
	cmp	DWORD PTR tv89[rsp], 1
	je	SHORT $LN1@MurmurHash
	cmp	DWORD PTR tv89[rsp], 2
	je	SHORT $LN2@MurmurHash
	cmp	DWORD PTR tv89[rsp], 3
	je	SHORT $LN3@MurmurHash
	jmp	SHORT $LN4@MurmurHash
$LN3@MurmurHash:

; 131  :   {
; 132  :   case 3: k1 ^= tail[2] << 16;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+2]
	shl	ecx, 16
	mov	eax, DWORD PTR k1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k1$[rsp], eax
$LN2@MurmurHash:

; 133  :   case 2: k1 ^= tail[1] << 8;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+1]
	shl	ecx, 8
	mov	eax, DWORD PTR k1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k1$[rsp], eax
$LN1@MurmurHash:

; 134  :   case 1: k1 ^= tail[0];

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax]
	mov	eax, DWORD PTR k1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k1$[rsp], eax

; 135  :           k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;

	mov	eax, DWORD PTR k1$[rsp]
	imul	eax, -862048943				; cc9e2d51H
	mov	DWORD PTR k1$[rsp], eax
	mov	edx, 15
	mov	ecx, DWORD PTR k1$[rsp]
	call	_rotl
	mov	DWORD PTR k1$[rsp], eax
	mov	eax, DWORD PTR k1$[rsp]
	imul	eax, 461845907				; 1b873593H
	mov	DWORD PTR k1$[rsp], eax
	mov	ecx, DWORD PTR k1$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
$LN4@MurmurHash:

; 136  :   };
; 137  : 
; 138  :   //----------
; 139  :   // finalization
; 140  : 
; 141  :   h1 ^= len;

	mov	ecx, DWORD PTR len$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h1$[rsp], eax

; 142  : 
; 143  :   h1 = fmix32(h1);

	mov	ecx, DWORD PTR h1$[rsp]
	call	?fmix32@@YAKK@Z				; fmix32
	mov	DWORD PTR h1$[rsp], eax

; 144  : 
; 145  :   *(uint32_t*)out = h1;

	mov	rcx, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	mov	DWORD PTR [rcx], eax

; 146  : } 

	add	rsp, 104				; 00000068H
	ret	0
?MurmurHash3_x86_32@@YAXPEBXHKPEAX@Z ENDP		; MurmurHash3_x86_32
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getblock32@@YAKPEBKH@Z
_TEXT	SEGMENT
p$ = 8
i$ = 16
?getblock32@@YAKPEBKH@Z PROC				; getblock32, COMDAT

; 56   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 57   :   return p[i];

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	mov	eax, DWORD PTR [rax+rcx*4]

; 58   : }

	ret	0
?getblock32@@YAKPEBKH@Z ENDP				; getblock32
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?fmix32@@YAKK@Z
_TEXT	SEGMENT
h$ = 8
?fmix32@@YAKK@Z PROC					; fmix32, COMDAT

; 69   : {

	mov	DWORD PTR [rsp+8], ecx

; 70   :   h ^= h >> 16;

	mov	ecx, DWORD PTR h$[rsp]
	shr	ecx, 16
	mov	eax, DWORD PTR h$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 71   :   h *= 0x85ebca6b;

	mov	eax, DWORD PTR h$[rsp]
	imul	eax, -2048144789			; 85ebca6bH
	mov	DWORD PTR h$[rsp], eax

; 72   :   h ^= h >> 13;

	mov	ecx, DWORD PTR h$[rsp]
	shr	ecx, 13
	mov	eax, DWORD PTR h$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 73   :   h *= 0xc2b2ae35;

	mov	eax, DWORD PTR h$[rsp]
	imul	eax, -1028477387			; c2b2ae35H
	mov	DWORD PTR h$[rsp], eax

; 74   :   h ^= h >> 16;

	mov	ecx, DWORD PTR h$[rsp]
	shr	ecx, 16
	mov	eax, DWORD PTR h$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 75   : 
; 76   :   return h;

	mov	eax, DWORD PTR h$[rsp]

; 77   : }

	ret	0
?fmix32@@YAKK@Z ENDP					; fmix32
_TEXT	ENDS
PUBLIC	?MurmurHash3_x86_128@@YAXPEBXHKPEAX@Z		; MurmurHash3_x86_128
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$?MurmurHash3_x86_128@@YAXPEBXHKPEAX@Z DD imagerel $LN24
	DD	imagerel $LN24+1900
	DD	imagerel $unwind$?MurmurHash3_x86_128@@YAXPEBXHKPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?MurmurHash3_x86_128@@YAXPEBXHKPEAX@Z DD 021a01H
	DD	013011aH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
h2$ = 32
k4$ = 36
c3$ = 40
h1$ = 44
c1$ = 48
tail$ = 56
c2$ = 64
nblocks$ = 68
h4$ = 72
blocks$ = 80
h3$ = 88
k3$ = 92
k2$ = 96
data$ = 104
c4$ = 112
k1$ = 116
i$4843 = 120
k4$4850 = 124
k3$4849 = 128
k2$4848 = 132
k1$4847 = 136
tv174 = 140
key$ = 160
len$ = 168
seed$ = 176
out$ = 184
?MurmurHash3_x86_128@@YAXPEBXHKPEAX@Z PROC		; MurmurHash3_x86_128

; 152  : {

$LN24:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 153  :   const uint8_t * data = (const uint8_t*)key;

	mov	rax, QWORD PTR key$[rsp]
	mov	QWORD PTR data$[rsp], rax

; 154  :   const int nblocks = len / 16;

	mov	eax, DWORD PTR len$[rsp]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR nblocks$[rsp], eax

; 155  : 
; 156  :   uint32_t h1 = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR h1$[rsp], eax

; 157  :   uint32_t h2 = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR h2$[rsp], eax

; 158  :   uint32_t h3 = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR h3$[rsp], eax

; 159  :   uint32_t h4 = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR h4$[rsp], eax

; 160  : 
; 161  :   const uint32_t c1 = 0x239b961b; 

	mov	DWORD PTR c1$[rsp], 597399067		; 239b961bH

; 162  :   const uint32_t c2 = 0xab0e9789;

	mov	DWORD PTR c2$[rsp], -1425107063		; ab0e9789H

; 163  :   const uint32_t c3 = 0x38b34ae5; 

	mov	DWORD PTR c3$[rsp], 951274213		; 38b34ae5H

; 164  :   const uint32_t c4 = 0xa1e38b93;

	mov	DWORD PTR c4$[rsp], -1578923117		; a1e38b93H

; 165  : 
; 166  :   //----------
; 167  :   // body
; 168  : 
; 169  :   const uint32_t * blocks = (const uint32_t *)(data + nblocks*16);

	mov	eax, DWORD PTR nblocks$[rsp]
	imul	eax, 16
	movsxd	rcx, eax
	mov	rax, QWORD PTR data$[rsp]
	add	rax, rcx
	mov	QWORD PTR blocks$[rsp], rax

; 170  : 
; 171  :   for(int i = -nblocks; i; i++)

	mov	eax, DWORD PTR nblocks$[rsp]
	neg	eax
	mov	DWORD PTR i$4843[rsp], eax
	jmp	SHORT $LN20@MurmurHash@2
$LN19@MurmurHash@2:
	mov	eax, DWORD PTR i$4843[rsp]
	add	eax, 1
	mov	DWORD PTR i$4843[rsp], eax
$LN20@MurmurHash@2:
	cmp	DWORD PTR i$4843[rsp], 0
	je	$LN18@MurmurHash@2

; 172  :   {
; 173  :     uint32_t k1 = getblock32(blocks,i*4+0);

	mov	edx, DWORD PTR i$4843[rsp]
	shl	edx, 2
	mov	rcx, QWORD PTR blocks$[rsp]
	call	?getblock32@@YAKPEBKH@Z			; getblock32
	mov	DWORD PTR k1$4847[rsp], eax

; 174  :     uint32_t k2 = getblock32(blocks,i*4+1);

	mov	edx, DWORD PTR i$4843[rsp]
	lea	edx, DWORD PTR [rdx*4+1]
	mov	rcx, QWORD PTR blocks$[rsp]
	call	?getblock32@@YAKPEBKH@Z			; getblock32
	mov	DWORD PTR k2$4848[rsp], eax

; 175  :     uint32_t k3 = getblock32(blocks,i*4+2);

	mov	edx, DWORD PTR i$4843[rsp]
	lea	edx, DWORD PTR [rdx*4+2]
	mov	rcx, QWORD PTR blocks$[rsp]
	call	?getblock32@@YAKPEBKH@Z			; getblock32
	mov	DWORD PTR k3$4849[rsp], eax

; 176  :     uint32_t k4 = getblock32(blocks,i*4+3);

	mov	edx, DWORD PTR i$4843[rsp]
	lea	edx, DWORD PTR [rdx*4+3]
	mov	rcx, QWORD PTR blocks$[rsp]
	call	?getblock32@@YAKPEBKH@Z			; getblock32
	mov	DWORD PTR k4$4850[rsp], eax

; 177  : 
; 178  :     k1 *= c1; k1  = ROTL32(k1,15); k1 *= c2; h1 ^= k1;

	mov	eax, DWORD PTR k1$4847[rsp]
	imul	eax, 597399067				; 239b961bH
	mov	DWORD PTR k1$4847[rsp], eax
	mov	edx, 15
	mov	ecx, DWORD PTR k1$4847[rsp]
	call	_rotl
	mov	DWORD PTR k1$4847[rsp], eax
	mov	eax, DWORD PTR k1$4847[rsp]
	imul	eax, -1425107063			; ab0e9789H
	mov	DWORD PTR k1$4847[rsp], eax
	mov	ecx, DWORD PTR k1$4847[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h1$[rsp], eax

; 179  : 
; 180  :     h1 = ROTL32(h1,19); h1 += h2; h1 = h1*5+0x561ccd1b;

	mov	edx, 19
	mov	ecx, DWORD PTR h1$[rsp]
	call	_rotl
	mov	DWORD PTR h1$[rsp], eax
	mov	ecx, DWORD PTR h2$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	add	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
	mov	eax, DWORD PTR h1$[rsp]
	imul	eax, 5
	add	eax, 1444728091				; 561ccd1bH
	mov	DWORD PTR h1$[rsp], eax

; 181  : 
; 182  :     k2 *= c2; k2  = ROTL32(k2,16); k2 *= c3; h2 ^= k2;

	mov	eax, DWORD PTR k2$4848[rsp]
	imul	eax, -1425107063			; ab0e9789H
	mov	DWORD PTR k2$4848[rsp], eax
	mov	edx, 16
	mov	ecx, DWORD PTR k2$4848[rsp]
	call	_rotl
	mov	DWORD PTR k2$4848[rsp], eax
	mov	eax, DWORD PTR k2$4848[rsp]
	imul	eax, 951274213				; 38b34ae5H
	mov	DWORD PTR k2$4848[rsp], eax
	mov	ecx, DWORD PTR k2$4848[rsp]
	mov	eax, DWORD PTR h2$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h2$[rsp], eax

; 183  : 
; 184  :     h2 = ROTL32(h2,17); h2 += h3; h2 = h2*5+0x0bcaa747;

	mov	edx, 17
	mov	ecx, DWORD PTR h2$[rsp]
	call	_rotl
	mov	DWORD PTR h2$[rsp], eax
	mov	ecx, DWORD PTR h3$[rsp]
	mov	eax, DWORD PTR h2$[rsp]
	add	eax, ecx
	mov	DWORD PTR h2$[rsp], eax
	mov	eax, DWORD PTR h2$[rsp]
	imul	eax, 5
	add	eax, 197830471				; 0bcaa747H
	mov	DWORD PTR h2$[rsp], eax

; 185  : 
; 186  :     k3 *= c3; k3  = ROTL32(k3,17); k3 *= c4; h3 ^= k3;

	mov	eax, DWORD PTR k3$4849[rsp]
	imul	eax, 951274213				; 38b34ae5H
	mov	DWORD PTR k3$4849[rsp], eax
	mov	edx, 17
	mov	ecx, DWORD PTR k3$4849[rsp]
	call	_rotl
	mov	DWORD PTR k3$4849[rsp], eax
	mov	eax, DWORD PTR k3$4849[rsp]
	imul	eax, -1578923117			; a1e38b93H
	mov	DWORD PTR k3$4849[rsp], eax
	mov	ecx, DWORD PTR k3$4849[rsp]
	mov	eax, DWORD PTR h3$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h3$[rsp], eax

; 187  : 
; 188  :     h3 = ROTL32(h3,15); h3 += h4; h3 = h3*5+0x96cd1c35;

	mov	edx, 15
	mov	ecx, DWORD PTR h3$[rsp]
	call	_rotl
	mov	DWORD PTR h3$[rsp], eax
	mov	ecx, DWORD PTR h4$[rsp]
	mov	eax, DWORD PTR h3$[rsp]
	add	eax, ecx
	mov	DWORD PTR h3$[rsp], eax
	mov	eax, DWORD PTR h3$[rsp]
	imul	eax, 5
	add	eax, -1764942795			; 96cd1c35H
	mov	DWORD PTR h3$[rsp], eax

; 189  : 
; 190  :     k4 *= c4; k4  = ROTL32(k4,18); k4 *= c1; h4 ^= k4;

	mov	eax, DWORD PTR k4$4850[rsp]
	imul	eax, -1578923117			; a1e38b93H
	mov	DWORD PTR k4$4850[rsp], eax
	mov	edx, 18
	mov	ecx, DWORD PTR k4$4850[rsp]
	call	_rotl
	mov	DWORD PTR k4$4850[rsp], eax
	mov	eax, DWORD PTR k4$4850[rsp]
	imul	eax, 597399067				; 239b961bH
	mov	DWORD PTR k4$4850[rsp], eax
	mov	ecx, DWORD PTR k4$4850[rsp]
	mov	eax, DWORD PTR h4$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h4$[rsp], eax

; 191  : 
; 192  :     h4 = ROTL32(h4,13); h4 += h1; h4 = h4*5+0x32ac3b17;

	mov	edx, 13
	mov	ecx, DWORD PTR h4$[rsp]
	call	_rotl
	mov	DWORD PTR h4$[rsp], eax
	mov	ecx, DWORD PTR h1$[rsp]
	mov	eax, DWORD PTR h4$[rsp]
	add	eax, ecx
	mov	DWORD PTR h4$[rsp], eax
	mov	eax, DWORD PTR h4$[rsp]
	imul	eax, 5
	add	eax, 850148119				; 32ac3b17H
	mov	DWORD PTR h4$[rsp], eax

; 193  :   }

	jmp	$LN19@MurmurHash@2
$LN18@MurmurHash@2:

; 194  : 
; 195  :   //----------
; 196  :   // tail
; 197  : 
; 198  :   const uint8_t * tail = (const uint8_t*)(data + nblocks*16);

	mov	eax, DWORD PTR nblocks$[rsp]
	imul	eax, 16
	movsxd	rcx, eax
	mov	rax, QWORD PTR data$[rsp]
	add	rax, rcx
	mov	QWORD PTR tail$[rsp], rax

; 199  : 
; 200  :   uint32_t k1 = 0;

	mov	DWORD PTR k1$[rsp], 0

; 201  :   uint32_t k2 = 0;

	mov	DWORD PTR k2$[rsp], 0

; 202  :   uint32_t k3 = 0;

	mov	DWORD PTR k3$[rsp], 0

; 203  :   uint32_t k4 = 0;

	mov	DWORD PTR k4$[rsp], 0

; 204  : 
; 205  :   switch(len & 15)

	mov	eax, DWORD PTR len$[rsp]
	and	eax, 15
	mov	DWORD PTR tv174[rsp], eax
	mov	eax, DWORD PTR tv174[rsp]
	sub	eax, 1
	mov	DWORD PTR tv174[rsp], eax
	cmp	DWORD PTR tv174[rsp], 14
	ja	$LN16@MurmurHash@2
	movsxd	rax, DWORD PTR tv174[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN23@MurmurHash@2[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN15@MurmurHash@2:

; 206  :   {
; 207  :   case 15: k4 ^= tail[14] << 16;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+14]
	shl	ecx, 16
	mov	eax, DWORD PTR k4$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k4$[rsp], eax
$LN14@MurmurHash@2:

; 208  :   case 14: k4 ^= tail[13] << 8;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+13]
	shl	ecx, 8
	mov	eax, DWORD PTR k4$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k4$[rsp], eax
$LN13@MurmurHash@2:

; 209  :   case 13: k4 ^= tail[12] << 0;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+12]
	mov	eax, DWORD PTR k4$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k4$[rsp], eax

; 210  :            k4 *= c4; k4  = ROTL32(k4,18); k4 *= c1; h4 ^= k4;

	mov	eax, DWORD PTR k4$[rsp]
	imul	eax, -1578923117			; a1e38b93H
	mov	DWORD PTR k4$[rsp], eax
	mov	edx, 18
	mov	ecx, DWORD PTR k4$[rsp]
	call	_rotl
	mov	DWORD PTR k4$[rsp], eax
	mov	eax, DWORD PTR k4$[rsp]
	imul	eax, 597399067				; 239b961bH
	mov	DWORD PTR k4$[rsp], eax
	mov	ecx, DWORD PTR k4$[rsp]
	mov	eax, DWORD PTR h4$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h4$[rsp], eax
$LN12@MurmurHash@2:

; 211  : 
; 212  :   case 12: k3 ^= tail[11] << 24;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+11]
	shl	ecx, 24
	mov	eax, DWORD PTR k3$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k3$[rsp], eax
$LN11@MurmurHash@2:

; 213  :   case 11: k3 ^= tail[10] << 16;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+10]
	shl	ecx, 16
	mov	eax, DWORD PTR k3$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k3$[rsp], eax
$LN10@MurmurHash@2:

; 214  :   case 10: k3 ^= tail[ 9] << 8;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+9]
	shl	ecx, 8
	mov	eax, DWORD PTR k3$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k3$[rsp], eax
$LN9@MurmurHash@2:

; 215  :   case  9: k3 ^= tail[ 8] << 0;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+8]
	mov	eax, DWORD PTR k3$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k3$[rsp], eax

; 216  :            k3 *= c3; k3  = ROTL32(k3,17); k3 *= c4; h3 ^= k3;

	mov	eax, DWORD PTR k3$[rsp]
	imul	eax, 951274213				; 38b34ae5H
	mov	DWORD PTR k3$[rsp], eax
	mov	edx, 17
	mov	ecx, DWORD PTR k3$[rsp]
	call	_rotl
	mov	DWORD PTR k3$[rsp], eax
	mov	eax, DWORD PTR k3$[rsp]
	imul	eax, -1578923117			; a1e38b93H
	mov	DWORD PTR k3$[rsp], eax
	mov	ecx, DWORD PTR k3$[rsp]
	mov	eax, DWORD PTR h3$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h3$[rsp], eax
$LN8@MurmurHash@2:

; 217  : 
; 218  :   case  8: k2 ^= tail[ 7] << 24;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+7]
	shl	ecx, 24
	mov	eax, DWORD PTR k2$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k2$[rsp], eax
$LN7@MurmurHash@2:

; 219  :   case  7: k2 ^= tail[ 6] << 16;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+6]
	shl	ecx, 16
	mov	eax, DWORD PTR k2$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k2$[rsp], eax
$LN6@MurmurHash@2:

; 220  :   case  6: k2 ^= tail[ 5] << 8;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+5]
	shl	ecx, 8
	mov	eax, DWORD PTR k2$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k2$[rsp], eax
$LN5@MurmurHash@2:

; 221  :   case  5: k2 ^= tail[ 4] << 0;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+4]
	mov	eax, DWORD PTR k2$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k2$[rsp], eax

; 222  :            k2 *= c2; k2  = ROTL32(k2,16); k2 *= c3; h2 ^= k2;

	mov	eax, DWORD PTR k2$[rsp]
	imul	eax, -1425107063			; ab0e9789H
	mov	DWORD PTR k2$[rsp], eax
	mov	edx, 16
	mov	ecx, DWORD PTR k2$[rsp]
	call	_rotl
	mov	DWORD PTR k2$[rsp], eax
	mov	eax, DWORD PTR k2$[rsp]
	imul	eax, 951274213				; 38b34ae5H
	mov	DWORD PTR k2$[rsp], eax
	mov	ecx, DWORD PTR k2$[rsp]
	mov	eax, DWORD PTR h2$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h2$[rsp], eax
$LN4@MurmurHash@2:

; 223  : 
; 224  :   case  4: k1 ^= tail[ 3] << 24;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+3]
	shl	ecx, 24
	mov	eax, DWORD PTR k1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k1$[rsp], eax
$LN3@MurmurHash@2:

; 225  :   case  3: k1 ^= tail[ 2] << 16;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+2]
	shl	ecx, 16
	mov	eax, DWORD PTR k1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k1$[rsp], eax
$LN2@MurmurHash@2:

; 226  :   case  2: k1 ^= tail[ 1] << 8;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+1]
	shl	ecx, 8
	mov	eax, DWORD PTR k1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k1$[rsp], eax
$LN1@MurmurHash@2:

; 227  :   case  1: k1 ^= tail[ 0] << 0;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax]
	mov	eax, DWORD PTR k1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR k1$[rsp], eax

; 228  :            k1 *= c1; k1  = ROTL32(k1,15); k1 *= c2; h1 ^= k1;

	mov	eax, DWORD PTR k1$[rsp]
	imul	eax, 597399067				; 239b961bH
	mov	DWORD PTR k1$[rsp], eax
	mov	edx, 15
	mov	ecx, DWORD PTR k1$[rsp]
	call	_rotl
	mov	DWORD PTR k1$[rsp], eax
	mov	eax, DWORD PTR k1$[rsp]
	imul	eax, -1425107063			; ab0e9789H
	mov	DWORD PTR k1$[rsp], eax
	mov	ecx, DWORD PTR k1$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
$LN16@MurmurHash@2:

; 229  :   };
; 230  : 
; 231  :   //----------
; 232  :   // finalization
; 233  : 
; 234  :   h1 ^= len; h2 ^= len; h3 ^= len; h4 ^= len;

	mov	ecx, DWORD PTR len$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
	mov	ecx, DWORD PTR len$[rsp]
	mov	eax, DWORD PTR h2$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h2$[rsp], eax
	mov	ecx, DWORD PTR len$[rsp]
	mov	eax, DWORD PTR h3$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h3$[rsp], eax
	mov	ecx, DWORD PTR len$[rsp]
	mov	eax, DWORD PTR h4$[rsp]
	xor	eax, ecx
	mov	DWORD PTR h4$[rsp], eax

; 235  : 
; 236  :   h1 += h2; h1 += h3; h1 += h4;

	mov	ecx, DWORD PTR h2$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	add	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
	mov	ecx, DWORD PTR h3$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	add	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
	mov	ecx, DWORD PTR h4$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	add	eax, ecx
	mov	DWORD PTR h1$[rsp], eax

; 237  :   h2 += h1; h3 += h1; h4 += h1;

	mov	ecx, DWORD PTR h1$[rsp]
	mov	eax, DWORD PTR h2$[rsp]
	add	eax, ecx
	mov	DWORD PTR h2$[rsp], eax
	mov	ecx, DWORD PTR h1$[rsp]
	mov	eax, DWORD PTR h3$[rsp]
	add	eax, ecx
	mov	DWORD PTR h3$[rsp], eax
	mov	ecx, DWORD PTR h1$[rsp]
	mov	eax, DWORD PTR h4$[rsp]
	add	eax, ecx
	mov	DWORD PTR h4$[rsp], eax

; 238  : 
; 239  :   h1 = fmix32(h1);

	mov	ecx, DWORD PTR h1$[rsp]
	call	?fmix32@@YAKK@Z				; fmix32
	mov	DWORD PTR h1$[rsp], eax

; 240  :   h2 = fmix32(h2);

	mov	ecx, DWORD PTR h2$[rsp]
	call	?fmix32@@YAKK@Z				; fmix32
	mov	DWORD PTR h2$[rsp], eax

; 241  :   h3 = fmix32(h3);

	mov	ecx, DWORD PTR h3$[rsp]
	call	?fmix32@@YAKK@Z				; fmix32
	mov	DWORD PTR h3$[rsp], eax

; 242  :   h4 = fmix32(h4);

	mov	ecx, DWORD PTR h4$[rsp]
	call	?fmix32@@YAKK@Z				; fmix32
	mov	DWORD PTR h4$[rsp], eax

; 243  : 
; 244  :   h1 += h2; h1 += h3; h1 += h4;

	mov	ecx, DWORD PTR h2$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	add	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
	mov	ecx, DWORD PTR h3$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	add	eax, ecx
	mov	DWORD PTR h1$[rsp], eax
	mov	ecx, DWORD PTR h4$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	add	eax, ecx
	mov	DWORD PTR h1$[rsp], eax

; 245  :   h2 += h1; h3 += h1; h4 += h1;

	mov	ecx, DWORD PTR h1$[rsp]
	mov	eax, DWORD PTR h2$[rsp]
	add	eax, ecx
	mov	DWORD PTR h2$[rsp], eax
	mov	ecx, DWORD PTR h1$[rsp]
	mov	eax, DWORD PTR h3$[rsp]
	add	eax, ecx
	mov	DWORD PTR h3$[rsp], eax
	mov	ecx, DWORD PTR h1$[rsp]
	mov	eax, DWORD PTR h4$[rsp]
	add	eax, ecx
	mov	DWORD PTR h4$[rsp], eax

; 246  : 
; 247  :   ((uint32_t*)out)[0] = h1;

	mov	rcx, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR h1$[rsp]
	mov	DWORD PTR [rcx], eax

; 248  :   ((uint32_t*)out)[1] = h2;

	mov	rcx, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR h2$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 249  :   ((uint32_t*)out)[2] = h3;

	mov	rcx, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR h3$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 250  :   ((uint32_t*)out)[3] = h4;

	mov	rcx, QWORD PTR out$[rsp]
	mov	eax, DWORD PTR h4$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 251  : }

	add	rsp, 152				; 00000098H
	ret	0
	npad	1
$LN23@MurmurHash@2:
	DD	$LN1@MurmurHash@2
	DD	$LN2@MurmurHash@2
	DD	$LN3@MurmurHash@2
	DD	$LN4@MurmurHash@2
	DD	$LN5@MurmurHash@2
	DD	$LN6@MurmurHash@2
	DD	$LN7@MurmurHash@2
	DD	$LN8@MurmurHash@2
	DD	$LN9@MurmurHash@2
	DD	$LN10@MurmurHash@2
	DD	$LN11@MurmurHash@2
	DD	$LN12@MurmurHash@2
	DD	$LN13@MurmurHash@2
	DD	$LN14@MurmurHash@2
	DD	$LN15@MurmurHash@2
?MurmurHash3_x86_128@@YAXPEBXHKPEAX@Z ENDP		; MurmurHash3_x86_128
_TEXT	ENDS
PUBLIC	?fmix64@@YA_K_K@Z				; fmix64
PUBLIC	?getblock64@@YA_KPEB_KH@Z			; getblock64
PUBLIC	?MurmurHash3_x64_128@@YAXPEBXHKPEAX@Z		; MurmurHash3_x64_128
EXTRN	_rotl64:PROC
pdata	SEGMENT
$pdata$?MurmurHash3_x64_128@@YAXPEBXHKPEAX@Z DD imagerel $LN24
	DD	imagerel $LN24+1436
	DD	imagerel $unwind$?MurmurHash3_x64_128@@YAXPEBXHKPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?MurmurHash3_x64_128@@YAXPEBXHKPEAX@Z DD 021a01H
	DD	013011aH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
h2$ = 32
h1$ = 40
c1$ = 48
tail$ = 56
c2$ = 64
nblocks$ = 72
blocks$ = 80
k2$ = 88
data$ = 96
k1$ = 104
i$4895 = 112
k2$4900 = 120
k1$4899 = 128
tv138 = 136
key$ = 160
len$ = 168
seed$ = 176
out$ = 184
?MurmurHash3_x64_128@@YAXPEBXHKPEAX@Z PROC		; MurmurHash3_x64_128

; 257  : {

$LN24:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 258  :   const uint8_t * data = (const uint8_t*)key;

	mov	rax, QWORD PTR key$[rsp]
	mov	QWORD PTR data$[rsp], rax

; 259  :   const int nblocks = len / 16;

	mov	eax, DWORD PTR len$[rsp]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR nblocks$[rsp], eax

; 260  : 
; 261  :   uint64_t h1 = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	QWORD PTR h1$[rsp], rax

; 262  :   uint64_t h2 = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	QWORD PTR h2$[rsp], rax

; 263  : 
; 264  :   const uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);

	mov	rax, -8663945395140668459		; 87c37b91114253d5H
	mov	QWORD PTR c1$[rsp], rax

; 265  :   const uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);

	mov	rax, 5545529020109919103		; 4cf5ad432745937fH
	mov	QWORD PTR c2$[rsp], rax

; 266  : 
; 267  :   //----------
; 268  :   // body
; 269  : 
; 270  :   const uint64_t * blocks = (const uint64_t *)(data);

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR blocks$[rsp], rax

; 271  : 
; 272  :   for(int i = 0; i < nblocks; i++)

	mov	DWORD PTR i$4895[rsp], 0
	jmp	SHORT $LN20@MurmurHash@3
$LN19@MurmurHash@3:
	mov	eax, DWORD PTR i$4895[rsp]
	add	eax, 1
	mov	DWORD PTR i$4895[rsp], eax
$LN20@MurmurHash@3:
	mov	eax, DWORD PTR nblocks$[rsp]
	cmp	DWORD PTR i$4895[rsp], eax
	jge	$LN18@MurmurHash@3

; 273  :   {
; 274  :     uint64_t k1 = getblock64(blocks,i*2+0);

	mov	edx, DWORD PTR i$4895[rsp]
	add	edx, edx
	mov	rcx, QWORD PTR blocks$[rsp]
	call	?getblock64@@YA_KPEB_KH@Z		; getblock64
	mov	QWORD PTR k1$4899[rsp], rax

; 275  :     uint64_t k2 = getblock64(blocks,i*2+1);

	mov	edx, DWORD PTR i$4895[rsp]
	lea	edx, DWORD PTR [rdx+rdx+1]
	mov	rcx, QWORD PTR blocks$[rsp]
	call	?getblock64@@YA_KPEB_KH@Z		; getblock64
	mov	QWORD PTR k2$4900[rsp], rax

; 276  : 
; 277  :     k1 *= c1; k1  = ROTL64(k1,31); k1 *= c2; h1 ^= k1;

	mov	rcx, -8663945395140668459		; 87c37b91114253d5H
	mov	rax, QWORD PTR k1$4899[rsp]
	imul	rax, rcx
	mov	QWORD PTR k1$4899[rsp], rax
	mov	edx, 31
	mov	rcx, QWORD PTR k1$4899[rsp]
	call	_rotl64
	mov	QWORD PTR k1$4899[rsp], rax
	mov	rcx, 5545529020109919103		; 4cf5ad432745937fH
	mov	rax, QWORD PTR k1$4899[rsp]
	imul	rax, rcx
	mov	QWORD PTR k1$4899[rsp], rax
	mov	rcx, QWORD PTR k1$4899[rsp]
	mov	rax, QWORD PTR h1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR h1$[rsp], rax

; 278  : 
; 279  :     h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;

	mov	edx, 27
	mov	rcx, QWORD PTR h1$[rsp]
	call	_rotl64
	mov	QWORD PTR h1$[rsp], rax
	mov	rcx, QWORD PTR h2$[rsp]
	mov	rax, QWORD PTR h1$[rsp]
	add	rax, rcx
	mov	QWORD PTR h1$[rsp], rax
	mov	rax, QWORD PTR h1$[rsp]
	imul	rax, 5
	add	rax, 1390208809				; 52dce729H
	mov	QWORD PTR h1$[rsp], rax

; 280  : 
; 281  :     k2 *= c2; k2  = ROTL64(k2,33); k2 *= c1; h2 ^= k2;

	mov	rcx, 5545529020109919103		; 4cf5ad432745937fH
	mov	rax, QWORD PTR k2$4900[rsp]
	imul	rax, rcx
	mov	QWORD PTR k2$4900[rsp], rax
	mov	edx, 33					; 00000021H
	mov	rcx, QWORD PTR k2$4900[rsp]
	call	_rotl64
	mov	QWORD PTR k2$4900[rsp], rax
	mov	rcx, -8663945395140668459		; 87c37b91114253d5H
	mov	rax, QWORD PTR k2$4900[rsp]
	imul	rax, rcx
	mov	QWORD PTR k2$4900[rsp], rax
	mov	rcx, QWORD PTR k2$4900[rsp]
	mov	rax, QWORD PTR h2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR h2$[rsp], rax

; 282  : 
; 283  :     h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;

	mov	edx, 31
	mov	rcx, QWORD PTR h2$[rsp]
	call	_rotl64
	mov	QWORD PTR h2$[rsp], rax
	mov	rcx, QWORD PTR h1$[rsp]
	mov	rax, QWORD PTR h2$[rsp]
	add	rax, rcx
	mov	QWORD PTR h2$[rsp], rax
	mov	rax, QWORD PTR h2$[rsp]
	imul	rax, 5
	add	rax, 944331445				; 38495ab5H
	mov	QWORD PTR h2$[rsp], rax

; 284  :   }

	jmp	$LN19@MurmurHash@3
$LN18@MurmurHash@3:

; 285  : 
; 286  :   //----------
; 287  :   // tail
; 288  : 
; 289  :   const uint8_t * tail = (const uint8_t*)(data + nblocks*16);

	mov	eax, DWORD PTR nblocks$[rsp]
	imul	eax, 16
	movsxd	rcx, eax
	mov	rax, QWORD PTR data$[rsp]
	add	rax, rcx
	mov	QWORD PTR tail$[rsp], rax

; 290  : 
; 291  :   uint64_t k1 = 0;

	mov	QWORD PTR k1$[rsp], 0

; 292  :   uint64_t k2 = 0;

	mov	QWORD PTR k2$[rsp], 0

; 293  : 
; 294  :   switch(len & 15)

	mov	eax, DWORD PTR len$[rsp]
	and	eax, 15
	mov	DWORD PTR tv138[rsp], eax
	mov	eax, DWORD PTR tv138[rsp]
	sub	eax, 1
	mov	DWORD PTR tv138[rsp], eax
	cmp	DWORD PTR tv138[rsp], 14
	ja	$LN16@MurmurHash@3
	movsxd	rax, DWORD PTR tv138[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN23@MurmurHash@3[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN15@MurmurHash@3:

; 295  :   {
; 296  :   case 15: k2 ^= ((uint64_t)tail[14]) << 48;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+14]
	shl	rcx, 48					; 00000030H
	mov	rax, QWORD PTR k2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
$LN14@MurmurHash@3:

; 297  :   case 14: k2 ^= ((uint64_t)tail[13]) << 40;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+13]
	shl	rcx, 40					; 00000028H
	mov	rax, QWORD PTR k2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
$LN13@MurmurHash@3:

; 298  :   case 13: k2 ^= ((uint64_t)tail[12]) << 32;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+12]
	shl	rcx, 32					; 00000020H
	mov	rax, QWORD PTR k2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
$LN12@MurmurHash@3:

; 299  :   case 12: k2 ^= ((uint64_t)tail[11]) << 24;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+11]
	shl	rcx, 24
	mov	rax, QWORD PTR k2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
$LN11@MurmurHash@3:

; 300  :   case 11: k2 ^= ((uint64_t)tail[10]) << 16;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+10]
	shl	rcx, 16
	mov	rax, QWORD PTR k2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
$LN10@MurmurHash@3:

; 301  :   case 10: k2 ^= ((uint64_t)tail[ 9]) << 8;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+9]
	shl	rcx, 8
	mov	rax, QWORD PTR k2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
$LN9@MurmurHash@3:

; 302  :   case  9: k2 ^= ((uint64_t)tail[ 8]) << 0;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+8]
	mov	rax, QWORD PTR k2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k2$[rsp], rax

; 303  :            k2 *= c2; k2  = ROTL64(k2,33); k2 *= c1; h2 ^= k2;

	mov	rcx, 5545529020109919103		; 4cf5ad432745937fH
	mov	rax, QWORD PTR k2$[rsp]
	imul	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
	mov	edx, 33					; 00000021H
	mov	rcx, QWORD PTR k2$[rsp]
	call	_rotl64
	mov	QWORD PTR k2$[rsp], rax
	mov	rcx, -8663945395140668459		; 87c37b91114253d5H
	mov	rax, QWORD PTR k2$[rsp]
	imul	rax, rcx
	mov	QWORD PTR k2$[rsp], rax
	mov	rcx, QWORD PTR k2$[rsp]
	mov	rax, QWORD PTR h2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR h2$[rsp], rax
$LN8@MurmurHash@3:

; 304  : 
; 305  :   case  8: k1 ^= ((uint64_t)tail[ 7]) << 56;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+7]
	shl	rcx, 56					; 00000038H
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
$LN7@MurmurHash@3:

; 306  :   case  7: k1 ^= ((uint64_t)tail[ 6]) << 48;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+6]
	shl	rcx, 48					; 00000030H
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
$LN6@MurmurHash@3:

; 307  :   case  6: k1 ^= ((uint64_t)tail[ 5]) << 40;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+5]
	shl	rcx, 40					; 00000028H
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
$LN5@MurmurHash@3:

; 308  :   case  5: k1 ^= ((uint64_t)tail[ 4]) << 32;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+4]
	shl	rcx, 32					; 00000020H
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
$LN4@MurmurHash@3:

; 309  :   case  4: k1 ^= ((uint64_t)tail[ 3]) << 24;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+3]
	shl	rcx, 24
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
$LN3@MurmurHash@3:

; 310  :   case  3: k1 ^= ((uint64_t)tail[ 2]) << 16;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+2]
	shl	rcx, 16
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
$LN2@MurmurHash@3:

; 311  :   case  2: k1 ^= ((uint64_t)tail[ 1]) << 8;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax+1]
	shl	rcx, 8
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
$LN1@MurmurHash@3:

; 312  :   case  1: k1 ^= ((uint64_t)tail[ 0]) << 0;

	mov	rax, QWORD PTR tail$[rsp]
	movzx	ecx, BYTE PTR [rax]
	mov	rax, QWORD PTR k1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k1$[rsp], rax

; 313  :            k1 *= c1; k1  = ROTL64(k1,31); k1 *= c2; h1 ^= k1;

	mov	rcx, -8663945395140668459		; 87c37b91114253d5H
	mov	rax, QWORD PTR k1$[rsp]
	imul	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
	mov	edx, 31
	mov	rcx, QWORD PTR k1$[rsp]
	call	_rotl64
	mov	QWORD PTR k1$[rsp], rax
	mov	rcx, 5545529020109919103		; 4cf5ad432745937fH
	mov	rax, QWORD PTR k1$[rsp]
	imul	rax, rcx
	mov	QWORD PTR k1$[rsp], rax
	mov	rcx, QWORD PTR k1$[rsp]
	mov	rax, QWORD PTR h1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR h1$[rsp], rax
$LN16@MurmurHash@3:

; 314  :   };
; 315  : 
; 316  :   //----------
; 317  :   // finalization
; 318  : 
; 319  :   h1 ^= len; h2 ^= len;

	movsxd	rcx, DWORD PTR len$[rsp]
	mov	rax, QWORD PTR h1$[rsp]
	xor	rax, rcx
	mov	QWORD PTR h1$[rsp], rax
	movsxd	rcx, DWORD PTR len$[rsp]
	mov	rax, QWORD PTR h2$[rsp]
	xor	rax, rcx
	mov	QWORD PTR h2$[rsp], rax

; 320  : 
; 321  :   h1 += h2;

	mov	rcx, QWORD PTR h2$[rsp]
	mov	rax, QWORD PTR h1$[rsp]
	add	rax, rcx
	mov	QWORD PTR h1$[rsp], rax

; 322  :   h2 += h1;

	mov	rcx, QWORD PTR h1$[rsp]
	mov	rax, QWORD PTR h2$[rsp]
	add	rax, rcx
	mov	QWORD PTR h2$[rsp], rax

; 323  : 
; 324  :   h1 = fmix64(h1);

	mov	rcx, QWORD PTR h1$[rsp]
	call	?fmix64@@YA_K_K@Z			; fmix64
	mov	QWORD PTR h1$[rsp], rax

; 325  :   h2 = fmix64(h2);

	mov	rcx, QWORD PTR h2$[rsp]
	call	?fmix64@@YA_K_K@Z			; fmix64
	mov	QWORD PTR h2$[rsp], rax

; 326  : 
; 327  :   h1 += h2;

	mov	rcx, QWORD PTR h2$[rsp]
	mov	rax, QWORD PTR h1$[rsp]
	add	rax, rcx
	mov	QWORD PTR h1$[rsp], rax

; 328  :   h2 += h1;

	mov	rcx, QWORD PTR h1$[rsp]
	mov	rax, QWORD PTR h2$[rsp]
	add	rax, rcx
	mov	QWORD PTR h2$[rsp], rax

; 329  : 
; 330  :   ((uint64_t*)out)[0] = h1;

	mov	rcx, QWORD PTR out$[rsp]
	mov	rax, QWORD PTR h1$[rsp]
	mov	QWORD PTR [rcx], rax

; 331  :   ((uint64_t*)out)[1] = h2;

	mov	rcx, QWORD PTR out$[rsp]
	mov	rax, QWORD PTR h2$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 332  : }

	add	rsp, 152				; 00000098H
	ret	0
	npad	3
$LN23@MurmurHash@3:
	DD	$LN1@MurmurHash@3
	DD	$LN2@MurmurHash@3
	DD	$LN3@MurmurHash@3
	DD	$LN4@MurmurHash@3
	DD	$LN5@MurmurHash@3
	DD	$LN6@MurmurHash@3
	DD	$LN7@MurmurHash@3
	DD	$LN8@MurmurHash@3
	DD	$LN9@MurmurHash@3
	DD	$LN10@MurmurHash@3
	DD	$LN11@MurmurHash@3
	DD	$LN12@MurmurHash@3
	DD	$LN13@MurmurHash@3
	DD	$LN14@MurmurHash@3
	DD	$LN15@MurmurHash@3
?MurmurHash3_x64_128@@YAXPEBXHKPEAX@Z ENDP		; MurmurHash3_x64_128
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getblock64@@YA_KPEB_KH@Z
_TEXT	SEGMENT
p$ = 8
i$ = 16
?getblock64@@YA_KPEB_KH@Z PROC				; getblock64, COMDAT

; 61   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 62   :   return p[i];

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+rcx*8]

; 63   : }

	ret	0
?getblock64@@YA_KPEB_KH@Z ENDP				; getblock64
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?fmix64@@YA_K_K@Z
_TEXT	SEGMENT
k$ = 8
?fmix64@@YA_K_K@Z PROC					; fmix64, COMDAT

; 82   : {

	mov	QWORD PTR [rsp+8], rcx

; 83   :   k ^= k >> 33;

	mov	rcx, QWORD PTR k$[rsp]
	shr	rcx, 33					; 00000021H
	mov	rax, QWORD PTR k$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k$[rsp], rax

; 84   :   k *= BIG_CONSTANT(0xff51afd7ed558ccd);

	mov	rcx, -49064778989728563			; ff51afd7ed558ccdH
	mov	rax, QWORD PTR k$[rsp]
	imul	rax, rcx
	mov	QWORD PTR k$[rsp], rax

; 85   :   k ^= k >> 33;

	mov	rcx, QWORD PTR k$[rsp]
	shr	rcx, 33					; 00000021H
	mov	rax, QWORD PTR k$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k$[rsp], rax

; 86   :   k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);

	mov	rcx, -4265267296055464877		; c4ceb9fe1a85ec53H
	mov	rax, QWORD PTR k$[rsp]
	imul	rax, rcx
	mov	QWORD PTR k$[rsp], rax

; 87   :   k ^= k >> 33;

	mov	rcx, QWORD PTR k$[rsp]
	shr	rcx, 33					; 00000021H
	mov	rax, QWORD PTR k$[rsp]
	xor	rax, rcx
	mov	QWORD PTR k$[rsp], rax

; 88   : 
; 89   :   return k;

	mov	rax, QWORD PTR k$[rsp]

; 90   : }

	ret	0
?fmix64@@YA_K_K@Z ENDP					; fmix64
_TEXT	ENDS
END
